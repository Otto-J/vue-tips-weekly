# 🔥 (#70) Configuration driven templates

July 2022

Heyo!

我们在盛夏了。

我要在我的 2015 款 MBP 烧伤我的腿之前写完周刊。

但比起阳光和空气是值得的。

靠着空调，我才能在如此潮湿炎热的晚上睡觉。

我的空调已经超过 30 年历史了，看起来还能再使用 25 年。

空调运行起来噪声很大，但年复一年还能持续工作着。

哈哈，我知道你并不关心我的空调。

接下来开始周刊内容。

—Michael

## 🔥 Ref vs. Reactive

在使用 `composition API` 的时候，用 `ref` 好还是 `reactive` 更好？

这里列举一些 `ref` 比 `reactive` 有优势的地方。

使用 `ref` 包裹 js 对象，同时对比 `reactive` 和普通对象的使用场景，区别显而易见：

```javascript
// I can expect this ref to update reactively
if (burger.value.lettuce) {
  // ...
}

// I have no clue if this value is reactive
if (burger.lettuce) {
  // ...
}
```

使用 `watch` 方法时，`ref` 会自动解构，非常易用：

```javascript
// Ref
const refBurger = ref({ lettuce: true });
watch(
  // Not much, but it's a bit simpler to work with
  refBurger,
  () => console.log("The burger has changed"),
  { deep: true }
);

// Reactive
const reactiveBurger = reactive({ lettuce: true });
watch(
  () => burger,
  () => console.log("The burger has changed"),
  { deep: true }
);
```

使用 `ref` 还有一个优点，你可以在 `ref` 中放入 `reactive` 对象。这样可以任意组合 `reactive` 对象，底层还是使用 `ref`：

```javascript
const lettuce = ref(true);
const burger = reactive({
  // 把 ref 变成属性
  lettuce,
});

// 直接监听 reactive 对象
watchEffect(() => console.log(burger.lettuce));

// 也可以直接监听 ref
watch(lettuce, () => console.log("lettuce has changed"));

setTimeout(() => {
  // 更新 ref 的值，会自动触发所有的 watchers
  lettuce.value = false;
}, 500);
```

## 🔥 配置驱动模板

我简化模板的一个常用方式是**配置驱动**。

我不会像这样重复编写模板：

```html
<template>
  <div>
    <menuitem @click="openContact"> Open Contact </menuitem>
    <menuitem @click="createContact"> Create Contact </menuitem>
    <menuitem @click="sendEmail"> Send Email </menuitem>
    <menuitem @click="resetSystem" danger> Reset </menuitem>
  </div>
</template>
```

通常会重构成通过配置项来驱动渲染：

```html
<template>
  <div>
    <menuitem
      v-for="item in menuItems"
      :key="item.text"
      :danger="item.danger"
      @click="item.action"
    >
      {{ item.text }}
    </menuitem>
  </div>
</template>
```

```html
<script setup>
  const openContact = () => {
    /* ... */
  };
  const createContact = () => {
    /* ... */
  };
  const sendEmail = () => {
    /* ... */
  };
  const resetSystem = () => {
    /* ... */
  };

  const menuItems = [
    {
      text: "Open Contact",
      action: openContact,
    },
    {
      text: "Create Contact",
      action: createContact,
    },
    {
      text: "Send Email",
      action: sendEmail,
    },
    {
      text: "Reset System",
      action: resetSystem,
      danger: true,
    },
  ];
</script>
```

我们没有减少代码，但让代码更简洁了：

- **配置项更易读** — Reading code is complicated because you have to figure out what the logic is doing, but configuration is very straightforward to understand.
- **更少的逻辑意味着更少的 bug** — The config above is just a boring array with some objects. It's pretty simple, so it's unlikely that bugs would come from there.
- **动态组件会更灵活** — Because we've made this menu component dynamically render out the different menu items, we gain tremendous flexibility.

[关于这个观点](http://michaelnthiessen.com/reducing-redundant-repetition)，我写了这篇文章

## 📜 编写自己的 Vue.js

一个大家都感同身受的权衡问题，是使用现成的解决方案，还是自己重新实现一个方案？

[我写了一个自己的 Vue.js](https://www.dopefly.com/techblog/405/I-Wrote-My-Own-Vue-js)

## 💬 Chaos

“自动化的混乱会让混乱更快发生。” — Mark Fewster

## 🧠 间隔重复：循环的目的是什么？

**The best way to commit something to long-term memory is to periodically review it, gradually increasing the time between reviews 👨‍🔬**

**Actually remembering these tips is much more useful than just a quick distraction, so here's a tip from a couple weeks ago to jog your memory.**

I always forget this, so this tip is mostly for me — hopefully, I won't have to keep looking this up!

We have 3 types of `for` loops in Javascript:

1. `for...in`
2. `for...of`
3. `for`

But how do you know which one to use?

For iterating through **properties** of an object, use `for...in`:

```javascript
const numbers = {
  one: 1,
  two: 2,
  three: 3,
};

// We get the properties of the object, not the values
for (const number in numbers) {
  console.log(number);
}

// Prints: 'one' 'two' 'three'
```

Items in a **list** (also called an iterable object) like an Array or Set, we use `for...of`:

```javascript
const numbers = ["one", "two", "three"];

// We get each of the elements in the Array
for (const number of numbers) {
  console.log(number);
}

// Prints: 'one' 'two' 'three'
```

You _can_ use `for...in` with an Array since all the indices are just the object's properties. But you may not get them in the correct order, and you'll also get any other properties the Array has :/

And you know how to use a regular old `for` loop, which lets you have a lot more control with some extra typing.

_p.s. I also have two courses: [Reusable Components](https://michaelnthiessen.com/reusable-components) and [Clean Components](https://michaelnthiessen.com/clean-components)_

## 来源

https://michaelnthiessen.com/weekly-070-july-20/
